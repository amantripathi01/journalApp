// ********RoostGPT********
/*
Test generated by RoostGPT for test javaAstParserTesting using AI Type Open AI and AI Model gpt-4
ROOST_METHOD_HASH=greeting_01403b7bbf
ROOST_METHOD_SIG_HASH=greeting_36e6be2569
"""
Scenario 1: Verify greeting when WeatherResponse is not null
TestName: verifyGreetingWhenWeatherResponseIsNotNull
Description: This test is meant to check the greeting functionality when the weather response for the location is not null. The expected behavior is that the greeting should include the weather feels like information.
Execution:
  Arrange: Mock the Authentication and WeatherService. Set the weather response to a valid object and set feelslike to a certain value.
  Act: Invoke the greeting method.
  Assert: Check that the returned ResponseEntity status is OK and the body contains the weather feels like information.
Validation: The assertion verifies that the greeting includes weather feels like information when the weather response is not null. This test validates that the greeting provides weather information accurately when available.
Scenario 2: Verify greeting when WeatherResponse is null
TestName: verifyGreetingWhenWeatherResponseIsNull
Description: This test is meant to check the greeting functionality when the weather response for the location is null. The expected behavior is that the greeting should not include weather feels like information.
Execution:
  Arrange: Mock the Authentication and WeatherService. Set the weather response to null.
  Act: Invoke the greeting method.
  Assert: Check that the returned ResponseEntity status is OK and the body does not contain weather feels like information.
Validation: The assertion verifies that the greeting does not include weather feels like information when the weather response is null. This test validates that the greeting behaves correctly when no weather information is available.
Scenario 3: Verify greeting with different user names
TestName: verifyGreetingWithDifferentUserNames
Description: This test is meant to check the greeting functionality with different user names. The expected behavior is that the greeting should include the user name.
Execution:
  Arrange: Mock the Authentication and WeatherService. Set the user name to different values.
  Act: Invoke the greeting method for each user name.
  Assert: Check that the returned ResponseEntity status is OK and the body contains the user name.
Validation: The assertion verifies that the greeting includes the user name. This test validates that the greeting personalizes the message for each user.
Scenario 4: Exception handling when weather service fails
TestName: verifyExceptionHandlingWhenWeatherServiceFails
Description: This test is meant to check the exception handling when the weather service fails. The expected behavior is that the greeting should not include the weather feels like information.
Execution:
  Arrange: Mock the Authentication and WeatherService. Set the weather service to throw an exception.
  Act: Invoke the greeting method.
  Assert: Check that the returned ResponseEntity status is OK and the body does not contain weather feels like information.
Validation: The assertion verifies that the greeting does not include weather feels like information when the weather service fails. This test validates that the greeting handles service failures gracefully.
"""
*/
// ********RoostGPT********
package net.engineeringdigest.journalApp.controller;

import net.engineeringdigest.journalApp.api.response.WeatherResponse;
import net.engineeringdigest.journalApp.entity.User;
import net.engineeringdigest.journalApp.repository.UserRepository;
import net.engineeringdigest.journalApp.service.UserService;
import net.engineeringdigest.journalApp.service.WeatherService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import org.junit.jupiter.api.*;

@Tag("net.engineeringdigest.journalApp.service")
@Tag("net.engineeringdigest.journalApp.service.getWeather")
@Tag("net.engineeringdigest.journalApp.controller")
@Tag("net.engineeringdigest.journalApp.controller.greeting")
@ExtendWith(MockitoExtension.class)
public class UserControllerGreetingTest {

	@Mock
	private UserService userService;

	@Mock
	private UserRepository userRepository;

	@Mock
	private WeatherService weatherService;

	@InjectMocks
	private UserController userController;

	@BeforeEach
	public void setup() {
		SecurityContextHolder.getContext()
			.setAuthentication(new UsernamePasswordAuthenticationToken("username", "password"));
	}

	@Test
	public void verifyGreetingWhenWeatherResponseIsNotNull() {
		WeatherResponse weatherResponse = new WeatherResponse();
		WeatherResponse.Current current = new WeatherResponse.Current();
		current.setFeelslike(30.0);
		weatherResponse.setCurrent(current);
		when(weatherService.getWeather("Mumbai")).thenReturn(weatherResponse);
		ResponseEntity<?> responseEntity = userController.greeting();
		assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
		assertTrue(responseEntity.getBody().toString().contains(", Weather feels like 30.0"));
	}

	@Test
    public void verifyGreetingWhenWeatherResponseIsNull() {
        when(weatherService.getWeather("Mumbai")).thenReturn(null);
        ResponseEntity<?> responseEntity = userController.greeting();
        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
        assertFalse(responseEntity.getBody().toString().contains(", Weather feels like "));
    }

	@Test
	public void verifyGreetingWithDifferentUserNames() {
		String[] usernames = { "username1", "username2", "username3" };
		for (String username : usernames) {
			SecurityContextHolder.getContext()
				.setAuthentication(new UsernamePasswordAuthenticationToken(username, "password"));
			ResponseEntity<?> responseEntity = userController.greeting();
			assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
			assertTrue(responseEntity.getBody().toString().contains("Hi " + username));
		}
	}

	@Test
    public void verifyExceptionHandlingWhenWeatherServiceFails() {
        when(weatherService.getWeather("Mumbai")).thenThrow(new RuntimeException());
        ResponseEntity<?> responseEntity = userController.greeting();
        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
        assertFalse(responseEntity.getBody().toString().contains(", Weather feels like "));
    }

}