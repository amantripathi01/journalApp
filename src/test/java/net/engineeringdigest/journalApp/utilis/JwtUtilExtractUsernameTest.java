// ********RoostGPT********
/*
Test generated by RoostGPT for test javaAstParserTesting using AI Type Open AI and AI Model gpt-4
ROOST_METHOD_HASH=extractUsername_a0af92d926
ROOST_METHOD_SIG_HASH=extractUsername_4fe85f8fe9
"""
Scenario 1: Valid Token
Details:
  TestName: extractUsernameWithValidToken
  Description: This test is meant to check the extraction of username from a valid token.
  Execution:
    Arrange: Create a valid token with a known subject (username).
    Act: Invoke the extractUsername method with the valid token.
    Assert: Compare the returned username with the known username from the token.
  Validation:
    This assertion aims to verify that the method correctly extracts the username from valid tokens. The expected result is the known username because the token was created with this username. This test is significant as it confirms the method's basic functionality.
Scenario 2: Invalid Token
Details:
  TestName: extractUsernameWithInvalidToken
  Description: This test is meant to check the method's behavior when provided with an invalid token.
  Execution:
    Arrange: Create an invalid token (i.e., malformed, expired, etc.)
    Act: Invoke the extractUsername method with the invalid token.
    Assert: Expect an appropriate exception to be thrown.
  Validation:
    This assertion aims to verify that the method correctly handles invalid tokens by throwing an exception. This is important as it ensures the method can effectively reject unauthorized or incorrect requests.
Scenario 3: Null Token
Details:
  TestName: extractUsernameWithNullToken
  Description: This test is meant to check the method's behavior when provided with a null token.
  Execution:
    Arrange: No arrangement necessary as the token is null.
    Act: Invoke the extractUsername method with a null token.
    Assert: Expect a NullPointerException to be thrown.
  Validation:
    This assertion aims to verify that the method correctly handles null tokens by throwing a NullPointerException. This is crucial for preventing null pointer errors in the application.
Scenario 4: Token without a Subject
Details:
  TestName: extractUsernameFromTokenWithoutSubject
  Description: This test is meant to check the method's behavior when provided with a token that doesn't contain a subject (username).
  Execution:
    Arrange: Create a valid token without a subject.
    Act: Invoke the extractUsername method with this token.
    Assert: Expect the returned username to be null.
  Validation:
    This assertion aims to verify that the method correctly handles tokens without subjects by returning null. This is important as it ensures the method can effectively deal with tokens that lack the necessary information.
"""
*/
// ********RoostGPT********
package net.engineeringdigest.journalApp.utilis;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import io.jsonwebtoken.Claims;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.stereotype.Component;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import org.junit.jupiter.api.*;

@Tag("net.engineeringdigest.journalApp.utilis")
@Tag("net.engineeringdigest.journalApp.utilis.extractUsername")
@Tag("net.engineeringdigest.journalApp.utilis.extractAllClaims")
public class JwtUtilExtractUsernameTest {

	private JwtUtil jwtUtil;

	private final String SECRET_KEY = "TaK+HaV^uvCHEFsEVfypW#7g9^k*Z8$V";

	@BeforeEach
	public void setup() {
		jwtUtil = new JwtUtil();
	}

	@Test
	public void extractUsernameWithValidToken() {
		// Arrange
		String expectedUsername = "testUser";
		String validToken = Jwts.builder()
			.setSubject(expectedUsername)
			.signWith(Keys.hmacShaKeyFor(SECRET_KEY.getBytes()))
			.compact();
		Claims claims = mock(Claims.class);
		when(claims.getSubject()).thenReturn(expectedUsername);

		// Act
		String actualUsername = jwtUtil.extractUsername(validToken);

		// Assert
		assertEquals(expectedUsername, actualUsername);
	}

	@Test
	public void extractUsernameWithInvalidToken() {
		// Arrange
		String invalidToken = "invalidToken";

		// Act & Assert
		assertThrows(Exception.class, () -> jwtUtil.extractUsername(invalidToken));
	}

	@Test
	public void extractUsernameWithNullToken() {
		// Act & Assert
		assertThrows(NullPointerException.class, () -> jwtUtil.extractUsername(null));
	}

	@Test
	public void extractUsernameFromTokenWithoutSubject() {
		// Arrange
		String tokenWithoutSubject = Jwts.builder().signWith(Keys.hmacShaKeyFor(SECRET_KEY.getBytes())).compact();
		Claims claims = mock(Claims.class);
		when(claims.getSubject()).thenReturn(null);

		// Act
		String returnedUsername = jwtUtil.extractUsername(tokenWithoutSubject);

		// Assert
		assertEquals(null, returnedUsername);
	}

}